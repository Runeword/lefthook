skip_output:
  - meta
  - success

pre-commit:
  commands:
    auto-commit:
      priority: 100
      run: |
        # Check if AUTO_COMMIT marker is set (to avoid recursion)
        if [ "$AUTO_COMMIT" = "1" ]; then
          exit 0
        fi

        # Check if user provided a message (if so, skip auto-commit)
        if git rev-parse -q --verify MERGE_HEAD >/dev/null 2>&1; then
          exit 0
        fi

        # Stash unstaged changes to preserve them
        STASH_HASH=""
        if ! git diff --quiet; then
          git stash push -u -m "lefthook-auto-commit-$(date +%s)" --keep-index >/dev/null 2>&1
          # Capture the exact stash hash (most recent stash)
          STASH_HASH=$(git rev-parse stash@{0} 2>/dev/null)
        fi

        # Re-stage any files modified by formatting hooks
        # Check each originally staged file for modifications
        for file in $(git diff --cached --name-only); do
          if [ -f "$file" ]; then
            git add "$file"
          fi
        done

        # Get all staged files
        STAGED_FILES=$(git diff --cached --name-only)

        if [ -z "$STAGED_FILES" ]; then
          # Restore unstaged changes if we stashed them
          if [ -n "$STASH_HASH" ]; then
            git stash apply "$STASH_HASH" >/dev/null 2>&1
            git stash drop "$STASH_HASH" >/dev/null 2>&1
          fi
          exit 0
        fi

        # Commit each file individually with auto-generated message
        for file in $STAGED_FILES; do
          status=$(git diff --cached --name-status | grep "^[AMD]\s*$file$" | cut -f1)
          case $status in
            A) message="Add $file" ;;
            M) message="Update $file" ;;
            D) message="Delete $file" ;;
            *) message="$file" ;;
          esac

          # Set marker to prevent recursion and commit (suppress output)
          echo "  â†’ $message"
          AUTO_COMMIT=1 LEFTHOOK=0 git commit -q -m "$message" "$file"
        done

        # Restore unstaged changes if we stashed them
        if [ -n "$STASH_HASH" ]; then
          git stash apply "$STASH_HASH" >/dev/null 2>&1
          git stash drop "$STASH_HASH" >/dev/null 2>&1
        fi

        # Exit with error to cancel the original commit (files already committed)
        exit 1
